{
    "name": "crypto-wasm",
    "description": "Secure cryptographic operations module written in Go and compiled to WebAssembly. Provides comprehensive cryptographic functions including hashing, encryption, JWT handling, and password security.",
    "version": "1.0.0",
    "author": "Ben",
    "license": "MIT",
    "tags": [
        "cryptography",
        "security",
        "encryption",
        "hashing",
        "jwt",
        "password",
        "aes",
        "rsa",
        "bcrypt",
        "wasm",
        "go"
    ],
    "security": {
        "level": "high",
        "features": [
            "Secure random number generation",
            "Authenticated encryption (AES-GCM)",
            "Strong password hashing (bcrypt)",
            "JWT token security",
            "Input validation",
            "Memory-safe operations"
        ],
        "compliance": [
            "OWASP guidelines",
            "Cryptographic best practices",
            "Secure by default configuration"
        ]
    },
    "functions": [
        {
            "name": "hashSHA256",
            "description": "Generate SHA256 hash of input data",
            "parameters": [
                {
                    "name": "data",
                    "type": "string",
                    "description": "Data to hash"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "hash": "string (hex-encoded SHA256 hash)",
                "algorithm": "string ('SHA256')"
            },
            "security": "SHA256 is cryptographically secure for integrity verification",
            "example": "const result = hashSHA256('Hello World'); // { hash: 'a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e', algorithm: 'SHA256' }"
        },
        {
            "name": "hashSHA512",
            "description": "Generate SHA512 hash of input data",
            "parameters": [
                {
                    "name": "data",
                    "type": "string",
                    "description": "Data to hash"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "hash": "string (hex-encoded SHA512 hash)",
                "algorithm": "string ('SHA512')"
            },
            "security": "SHA512 provides higher security than SHA256 but at computational cost",
            "example": "const result = hashSHA512('Hello World');"
        },
        {
            "name": "hashMD5",
            "description": "Generate MD5 hash (legacy support only - not secure)",
            "parameters": [
                {
                    "name": "data",
                    "type": "string",
                    "description": "Data to hash"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "hash": "string (hex-encoded MD5 hash)",
                "algorithm": "string ('MD5')",
                "warning": "string (security warning)"
            },
            "security": "⚠️ MD5 is cryptographically broken - use only for legacy compatibility",
            "example": "const result = hashMD5('Hello World'); // Includes security warning"
        },
        {
            "name": "generateAESKey",
            "description": "Generate a random AES encryption key",
            "parameters": [
                {
                    "name": "keySize",
                    "type": "number",
                    "description": "Key size in bytes (16=128bit, 24=192bit, 32=256bit)",
                    "optional": true,
                    "default": 32
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "key": "string (base64-encoded key)",
                "keySize": "number (key size in bits)"
            },
            "security": "Uses cryptographically secure random number generation",
            "example": "const key = generateAESKey(32); // 256-bit key"
        },
        {
            "name": "encryptAES",
            "description": "Encrypt data using AES-GCM (authenticated encryption)",
            "parameters": [
                {
                    "name": "data",
                    "type": "string",
                    "description": "Data to encrypt"
                },
                {
                    "name": "key",
                    "type": "string",
                    "description": "Base64-encoded AES key"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "encryptedData": "string (base64-encoded encrypted data with nonce)",
                "algorithm": "string ('AES-GCM')"
            },
            "security": "AES-GCM provides both confidentiality and authenticity",
            "example": "const encrypted = encryptAES('secret data', key.key);"
        },
        {
            "name": "decryptAES",
            "description": "Decrypt data using AES-GCM",
            "parameters": [
                {
                    "name": "encryptedData",
                    "type": "string",
                    "description": "Base64-encoded encrypted data"
                },
                {
                    "name": "key",
                    "type": "string",
                    "description": "Base64-encoded AES key"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "decryptedData": "string (original plaintext)",
                "algorithm": "string ('AES-GCM')"
            },
            "security": "Automatic verification of authenticity tag",
            "example": "const decrypted = decryptAES(encrypted.encryptedData, key.key);"
        },
        {
            "name": "generateRSAKeyPair",
            "description": "Generate RSA public/private key pair",
            "parameters": [
                {
                    "name": "keySize",
                    "type": "number",
                    "description": "Key size in bits (1024-4096)",
                    "optional": true,
                    "default": 2048
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "publicKey": "string (PEM-formatted public key)",
                "privateKey": "string (PEM-formatted private key)",
                "keySize": "number (key size in bits)"
            },
            "security": "2048-bit minimum recommended for security",
            "example": "const keyPair = generateRSAKeyPair(2048);"
        },
        {
            "name": "encryptRSA",
            "description": "Encrypt data using RSA public key",
            "parameters": [
                {
                    "name": "data",
                    "type": "string",
                    "description": "Data to encrypt (limited by key size)"
                },
                {
                    "name": "publicKey",
                    "type": "string",
                    "description": "PEM-formatted RSA public key"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "encryptedData": "string (base64-encoded encrypted data)",
                "algorithm": "string ('RSA-PKCS1v15')"
            },
            "security": "Data size limited to key size minus padding",
            "example": "const encrypted = encryptRSA('secret', keyPair.publicKey);"
        },
        {
            "name": "decryptRSA",
            "description": "Decrypt data using RSA private key",
            "parameters": [
                {
                    "name": "encryptedData",
                    "type": "string",
                    "description": "Base64-encoded encrypted data"
                },
                {
                    "name": "privateKey",
                    "type": "string",
                    "description": "PEM-formatted RSA private key"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "decryptedData": "string (original plaintext)",
                "algorithm": "string ('RSA-PKCS1v15')"
            },
            "security": "Private key must be kept secure",
            "example": "const decrypted = decryptRSA(encrypted.encryptedData, keyPair.privateKey);"
        },
        {
            "name": "generateJWT",
            "description": "Generate a JWT token with HMAC-SHA256 signature",
            "parameters": [
                {
                    "name": "payload",
                    "type": "string",
                    "description": "JSON string of claims to include"
                },
                {
                    "name": "secret",
                    "type": "string",
                    "description": "Secret key for signing"
                },
                {
                    "name": "expirationHours",
                    "type": "number",
                    "description": "Token expiration in hours",
                    "optional": true,
                    "default": 24
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "token": "string (JWT token)",
                "expiresIn": "number (expiration in seconds)",
                "algorithm": "string ('HS256')"
            },
            "security": "Secret must be cryptographically strong",
            "example": "const jwt = generateJWT('{\"userId\":123}', 'strong-secret', 24);"
        },
        {
            "name": "verifyJWT",
            "description": "Verify and decode a JWT token",
            "parameters": [
                {
                    "name": "token",
                    "type": "string",
                    "description": "JWT token to verify"
                },
                {
                    "name": "secret",
                    "type": "string",
                    "description": "Secret key used for signing"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "valid": "boolean (token validity)",
                "claims": "string (JSON of claims if valid)",
                "algorithm": "string ('HS256')",
                "error": "string (error message if invalid)"
            },
            "security": "Automatically checks signature and expiration",
            "example": "const verification = verifyJWT(jwt.token, 'strong-secret');"
        },
        {
            "name": "bcryptHash",
            "description": "Hash password using bcrypt (adaptive hashing)",
            "parameters": [
                {
                    "name": "password",
                    "type": "string",
                    "description": "Password to hash"
                },
                {
                    "name": "cost",
                    "type": "number",
                    "description": "Cost factor (4-31, higher = more secure but slower)",
                    "optional": true,
                    "default": 10
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "hash": "string (bcrypt hash)",
                "cost": "number (cost factor used)",
                "algorithm": "string ('bcrypt')"
            },
            "security": "Industry standard for password hashing",
            "example": "const hash = bcryptHash('myPassword', 12);"
        },
        {
            "name": "bcryptVerify",
            "description": "Verify password against bcrypt hash",
            "parameters": [
                {
                    "name": "password",
                    "type": "string",
                    "description": "Password to verify"
                },
                {
                    "name": "hash",
                    "type": "string",
                    "description": "bcrypt hash to verify against"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "valid": "boolean (password match)",
                "algorithm": "string ('bcrypt')",
                "error": "string (error message if invalid)"
            },
            "security": "Constant-time comparison prevents timing attacks",
            "example": "const isValid = bcryptVerify('myPassword', hash.hash);"
        },
        {
            "name": "generateUUID",
            "description": "Generate a UUID v4 (random UUID)",
            "parameters": [],
            "returnType": "object",
            "returnProperties": {
                "uuid": "string (UUID v4)",
                "version": "number (4)"
            },
            "security": "Uses cryptographically secure random number generation",
            "example": "const uuid = generateUUID(); // { uuid: '550e8400-e29b-41d4-a716-446655440000', version: 4 }"
        },
        {
            "name": "generateRandomBytes",
            "description": "Generate cryptographically secure random bytes",
            "parameters": [
                {
                    "name": "length",
                    "type": "number",
                    "description": "Number of bytes to generate (1-1024)"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "bytes": "string (base64-encoded random bytes)",
                "length": "number (byte length)",
                "encoding": "string ('base64')"
            },
            "security": "Uses OS entropy source",
            "example": "const randomBytes = generateRandomBytes(32);"
        },
        {
            "name": "base64Encode",
            "description": "Encode data to base64",
            "parameters": [
                {
                    "name": "data",
                    "type": "string",
                    "description": "Data to encode"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "encoded": "string (base64-encoded data)",
                "originalLength": "number (original byte length)",
                "encodedLength": "number (encoded string length)"
            },
            "example": "const encoded = base64Encode('Hello World');"
        },
        {
            "name": "base64Decode",
            "description": "Decode base64 data",
            "parameters": [
                {
                    "name": "encodedData",
                    "type": "string",
                    "description": "Base64-encoded data to decode"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "decoded": "string (decoded data)",
                "encodedLength": "number (encoded string length)",
                "decodedLength": "number (decoded byte length)"
            },
            "example": "const decoded = base64Decode(encoded.encoded);"
        },
        {
            "name": "validatePasswordStrength",
            "description": "Validate password strength according to security best practices",
            "parameters": [
                {
                    "name": "password",
                    "type": "string",
                    "description": "Password to validate"
                }
            ],
            "returnType": "object",
            "returnProperties": {
                "score": "number (strength score 0-100)",
                "strength": "string (very_weak|weak|medium|strong|very_strong)",
                "issues": "array (list of validation issues)",
                "valid": "boolean (meets minimum requirements)"
            },
            "security": "Enforces OWASP password guidelines",
            "example": "const validation = validatePasswordStrength('MySecure123!');"
        },
        {
            "name": "getAvailableFunctions",
            "description": "Get list of all available cryptographic functions",
            "parameters": [],
            "returnType": "array",
            "returnProperties": "Array of function names",
            "example": "const functions = getAvailableFunctions();"
        },
        {
            "name": "setSilentMode",
            "description": "Enable or disable logging output",
            "parameters": [
                {
                    "name": "silent",
                    "type": "boolean",
                    "description": "Whether to enable silent mode"
                }
            ],
            "returnType": "boolean",
            "returnProperties": "Current silent mode state",
            "example": "setSilentMode(true);"
        }
    ],
    "types": {
        "TypeScript": "declare module 'crypto-wasm' {\n  export interface CryptoResult {\n    error?: string;\n  }\n\n  export interface HashResult extends CryptoResult {\n    hash: string;\n    algorithm: string;\n    warning?: string;\n  }\n\n  export interface KeyResult extends CryptoResult {\n    key: string;\n    keySize: number;\n  }\n\n  export interface EncryptionResult extends CryptoResult {\n    encryptedData: string;\n    algorithm: string;\n  }\n\n  export interface DecryptionResult extends CryptoResult {\n    decryptedData: string;\n    algorithm: string;\n  }\n\n  export interface KeyPairResult extends CryptoResult {\n    publicKey: string;\n    privateKey: string;\n    keySize: number;\n  }\n\n  export interface JWTResult extends CryptoResult {\n    token: string;\n    expiresIn: number;\n    algorithm: string;\n  }\n\n  export interface JWTVerificationResult extends CryptoResult {\n    valid: boolean;\n    claims?: string;\n    algorithm: string;\n  }\n\n  export interface HashingResult extends CryptoResult {\n    hash: string;\n    cost: number;\n    algorithm: string;\n  }\n\n  export interface VerificationResult extends CryptoResult {\n    valid: boolean;\n    algorithm: string;\n  }\n\n  export interface UUIDResult extends CryptoResult {\n    uuid: string;\n    version: number;\n  }\n\n  export interface RandomBytesResult extends CryptoResult {\n    bytes: string;\n    length: number;\n    encoding: string;\n  }\n\n  export interface EncodingResult extends CryptoResult {\n    encoded?: string;\n    decoded?: string;\n    originalLength?: number;\n    encodedLength?: number;\n    decodedLength?: number;\n  }\n\n  export interface PasswordValidation extends CryptoResult {\n    score: number;\n    strength: 'very_weak' | 'weak' | 'medium' | 'strong' | 'very_strong';\n    issues: string[];\n    valid: boolean;\n  }\n\n  // Function declarations\n  export function hashSHA256(data: string): HashResult;\n  export function hashSHA512(data: string): HashResult;\n  export function hashMD5(data: string): HashResult;\n  export function generateAESKey(keySize?: number): KeyResult;\n  export function encryptAES(data: string, key: string): EncryptionResult;\n  export function decryptAES(encryptedData: string, key: string): DecryptionResult;\n  export function generateRSAKeyPair(keySize?: number): KeyPairResult;\n  export function encryptRSA(data: string, publicKey: string): EncryptionResult;\n  export function decryptRSA(encryptedData: string, privateKey: string): DecryptionResult;\n  export function generateJWT(payload: string, secret: string, expirationHours?: number): JWTResult;\n  export function verifyJWT(token: string, secret: string): JWTVerificationResult;\n  export function bcryptHash(password: string, cost?: number): HashingResult;\n  export function bcryptVerify(password: string, hash: string): VerificationResult;\n  export function generateUUID(): UUIDResult;\n  export function generateRandomBytes(length: number): RandomBytesResult;\n  export function base64Encode(data: string): EncodingResult;\n  export function base64Decode(encodedData: string): EncodingResult;\n  export function validatePasswordStrength(password: string): PasswordValidation;\n  export function getAvailableFunctions(): string[];\n  export function setSilentMode(silent: boolean): boolean;\n}"
    },
    "performance": {
        "optimizations": [
            "Go compiler optimizations (-ldflags=\"-s -w\")",
            "WebAssembly size optimization",
            "Efficient memory management",
            "Minimal external dependencies",
            "Fast cryptographic implementations"
        ],
        "benchmarks": {
            "SHA256": "~50,000 ops/sec for 1KB data",
            "AES-256 encryption": "~10,000 ops/sec for 1KB data",
            "RSA-2048 encryption": "~500 ops/sec",
            "bcrypt (cost 10)": "~100 ops/sec",
            "JWT generation": "~5,000 ops/sec"
        }
    },
    "compatibility": {
        "browsers": [
            "Chrome 57+",
            "Firefox 52+",
            "Safari 11+",
            "Edge 16+"
        ],
        "node": "16+",
        "frameworks": [
            "React 16+",
            "Vue.js 2.6+/3.0+",
            "Angular 8+",
            "Next.js",
            "Nuxt.js"
        ]
    },
    "examples": {
        "javascript": {
            "basic_hashing": "// Hash data with SHA256\nconst hash = hashSHA256('Hello World');\nconsole.log(hash.hash); // hex string",
            "aes_encryption": "// Encrypt/decrypt with AES\nconst key = generateAESKey(32);\nconst encrypted = encryptAES('secret data', key.key);\nconst decrypted = decryptAES(encrypted.encryptedData, key.key);",
            "rsa_encryption": "// RSA key pair and encryption\nconst keyPair = generateRSAKeyPair(2048);\nconst encrypted = encryptRSA('secret', keyPair.publicKey);\nconst decrypted = decryptRSA(encrypted.encryptedData, keyPair.privateKey);",
            "jwt_handling": "// JWT token generation and verification\nconst payload = JSON.stringify({userId: 123, role: 'admin'});\nconst jwt = generateJWT(payload, 'secret-key', 24);\nconst verification = verifyJWT(jwt.token, 'secret-key');",
            "password_security": "// Secure password handling\nconst validation = validatePasswordStrength('MySecure123!');\nif (validation.valid) {\n  const hash = bcryptHash('MySecure123!', 12);\n  const isValid = bcryptVerify('MySecure123!', hash.hash);\n}"
        },
        "react": "import { useState, useEffect } from 'react';\nimport { load } from 'gowm';\n\nfunction CryptoComponent() {\n  const [crypto, setCrypto] = useState(null);\n  const [hash, setHash] = useState('');\n\n  useEffect(() => {\n    async function loadCrypto() {\n      const cryptoWasm = await load('./crypto-wasm/main.wasm');\n      setCrypto(cryptoWasm);\n    }\n    loadCrypto();\n  }, []);\n\n  const handleHash = () => {\n    if (crypto) {\n      const result = crypto.call('hashSHA256', 'Hello World');\n      setHash(result.hash);\n    }\n  };\n\n  return (\n    <div>\n      <button onClick={handleHash}>Generate Hash</button>\n      <p>Hash: {hash}</p>\n    </div>\n  );\n}",
        "vue": "<template>\n  <div>\n    <button @click=\"generateHash\">Generate Hash</button>\n    <p>Hash: {{ hash }}</p>\n  </div>\n</template>\n\n<script>\nimport { useWasm } from 'gowm/composables';\n\nexport default {\n  setup() {\n    const { wasm: crypto } = useWasm('./crypto-wasm/main.wasm');\n    const hash = ref('');\n\n    const generateHash = () => {\n      if (crypto.value) {\n        const result = crypto.value.call('hashSHA256', 'Hello World');\n        hash.value = result.hash;\n      }\n    };\n\n    return { hash, generateHash };\n  }\n};\n</script>"
    },
    "buildInfo": {
        "goVersion": "1.21+",
        "targetOS": "js",
        "targetArch": "wasm",
        "buildFlags": [
            "-ldflags=\"-s -w\"",
            "-trimpath",
            "-buildmode=default"
        ],
        "dependencies": [
            "golang.org/x/crypto",
            "github.com/golang-jwt/jwt/v5"
        ],
        "securityFeatures": [
            "CGO_ENABLED=0",
            "Stripped debug symbols",
            "Path trimming",
            "Dependency auditing"
        ]
    },
    "wasmConfig": {
        "memoryInitial": "256 pages (16MB)",
        "memoryMaximum": "512 pages (32MB)",
        "tableInitial": "1",
        "tableMaximum": "1",
        "globalMutable": true,
        "exportTable": false,
        "features": [
            "bulk-memory",
            "sign-extension"
        ]
    }
}