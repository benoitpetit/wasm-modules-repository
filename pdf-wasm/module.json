{
  "author": "Ben",
  "buildInfo": {
    "buildCommand": "wasm-manager build",
    "buildTime": "2025-06-18T23:28:03+02:00",
    "compilerFlags": [
      "GOOS=js",
      "GOARCH=wasm",
      "CGO_ENABLED=0",
      "-ldflags=-s -w -buildid=",
      "-trimpath",
      "-buildmode=default",
      "-tags=netgo,osusergo",
      "-a",
      "-gcflags=-l=4 -B",
      "wasm-opt=-Oz --enable-bulk-memory"
    ],
    "dependencies": [
      "github.com/jung-kurt/gofpdf"
    ],
    "goModule": true,
    "goVersion": "1.24.3",
    "language": "Go",
    "lastModified": "2025-06-18T23:28:02+02:00",
    "outputFile": "main.wasm",
    "target": "js/wasm",
    "wasmOptUsed": true
  },
  "buildTime": 1750282083,
  "changelog": {
    "changes": [
      "Initial PDF module implementation",
      "PDF creation from scratch with custom pages",
      "Page manipulation (add pages to existing PDFs)",
      "Text and image extraction capabilities",
      "PDF merging and splitting functionality",
      "Watermarking with configurable styling",
      "Template-based report generation",
      "PDF compression with multiple levels",
      "Metadata extraction and modification",
      "Full GoWM integration and compatibility"
    ],
    "releaseDate": "2025-06-18",
    "version": "0.1.0"
  },
  "compatibility": {
    "browsers": [
      "Chrome 69+",
      "Firefox 79+",
      "Safari 15+",
      "Edge 79+"
    ],
    "gowm": "1.0.0+",
    "nodejs": "14.0.0+"
  },
  "description": "Complete PDF manipulation module written in Go and compiled to WebAssembly. Provides comprehensive PDF operations with GoWM integration.",
  "ecosystem": {
    "category": "documents",
    "industry": [
      "business",
      "legal",
      "healthcare",
      "education",
      "finance"
    ],
    "relatedModules": [
      "image-wasm",
      "compress-wasm"
    ],
    "subcategory": "pdf",
    "useCase": [
      "document-generation",
      "report-automation",
      "form-processing",
      "archiving"
    ]
  },
  "errorHandling": {
    "description": "PDF module returns objects with 'error' field when operations fail",
    "detection": "if (result.error) { /* handle error */ } else { /* use result data */ }",
    "examples": [
      {
        "cause": "Called extractText() with malformed base64 PDF data",
        "error": "Invalid PDF data: illegal base64 data at input byte 15"
      },
      {
        "cause": "Called createPDF() with empty or invalid page configurations",
        "error": "Failed to generate PDF: insufficient page content"
      },
      {
        "cause": "Called addWatermark() with opacity outside 0-1 range",
        "error": "Watermark addition failed: invalid opacity value"
      },
      {
        "cause": "Called mergePDFs() with less than 2 PDF documents",
        "error": "PDF merge failed: at least 2 PDFs required"
      }
    ],
    "pattern": "object-based"
  },
  "examples": [
    {
      "code": "import { loadFromGitHub } from 'gowm';\n\n// Load PDF module from wasm-modules-repository\nconst pdf = await loadFromGitHub('benoitpetit/wasm-modules-repository', {\n  path: 'pdf-wasm',\n  filename: 'main.wasm',\n  name: 'pdf-wasm',\n  branch: 'master'\n});\n\n// Configure module\npdf.call('setSilentMode', true);\n\n// Create PDF with error handling\nconst pages = JSON.stringify([{\n  content: 'Hello PDF World!\\nThis is my first page.',\n  margin: 15\n}]);\n\nconst result = pdf.call('createPDF', pages);\nif (result.error) {\n  console.error('PDF creation error:', result.error);\n} else {\n  console.log('PDF created successfully!');\n  console.log('Size:', result.size, 'bytes');\n  console.log('Pages:', result.pages);\n  \n  // Download the PDF\n  const blob = new Blob([atob(result.pdfData)], {type: 'application/pdf'});\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = 'my-document.pdf';\n  a.click();\n}",
      "language": "javascript",
      "title": "GoWM Integration - Basic PDF Creation"
    },
    {
      "code": "// Complete PDF workflow with multiple operations\nasync function processPDF() {\n  // Step 1: Create initial PDF\n  const pages = JSON.stringify([{\n    content: 'Original Document\\nThis is the main content.',\n    margin: 10\n  }]);\n  \n  let result = pdf.call('createPDF', pages, JSON.stringify({\n    title: 'Business Report',\n    author: 'John Doe',\n    subject: 'Quarterly Analysis'\n  }));\n  \n  if (result.error) throw new Error(result.error);\n  let pdfData = result.pdfData;\n  \n  // Step 2: Add watermark\n  const watermark = JSON.stringify({\n    text: 'CONFIDENTIAL',\n    opacity: 0.3,\n    rotation: 45\n  });\n  \n  result = pdf.call('addWatermark', pdfData, watermark);\n  if (result.error) throw new Error(result.error);\n  pdfData = result.pdfData;\n  \n  // Step 3: Compress PDF\n  result = pdf.call('compressPDF', pdfData, 'high');\n  if (result.error) throw new Error(result.error);\n  \n  console.log('Final PDF processed:');\n  console.log('- Original size:', result.originalSize, 'bytes');\n  console.log('- Compressed size:', result.compressedSize, 'bytes');\n  console.log('- Compression ratio:', result.compressionRatio + '%');\n  \n  return result.pdfData;\n}",
      "language": "javascript",
      "title": "Advanced PDF Manipulation"
    },
    {
      "code": "import React, { useState, useEffect } from 'react';\nimport { useWasmFromGitHub } from 'gowm/hooks/useWasm';\n\nfunction PDFGenerator() {\n  const { wasm: pdf, loading, error } = useWasmFromGitHub('benoitpetit/wasm-modules-repository', {\n    path: 'pdf-wasm',\n    filename: 'main.wasm',\n    name: 'pdf-wasm',\n    branch: 'master'\n  });\n  \n  const [content, setContent] = useState('Hello PDF World!');\n  const [pdfResult, setPdfResult] = useState(null);\n  const [functions, setFunctions] = useState([]);\n\n  useEffect(() =\u003e {\n    if (pdf) {\n      pdf.call('setSilentMode', true);\n      const availableFunctions = pdf.call('getAvailableFunctions');\n      setFunctions(availableFunctions);\n    }\n  }, [pdf]);\n\n  const generatePDF = () =\u003e {\n    if (!pdf) return;\n    \n    const pages = JSON.stringify([{\n      content: content,\n      margin: 15\n    }]);\n    \n    const result = pdf.call('createPDF', pages);\n    if (result.error) {\n      setPdfResult({ error: result.error });\n    } else {\n      setPdfResult(result);\n      \n      // Auto-download\n      const blob = new Blob([atob(result.pdfData)], {type: 'application/pdf'});\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = 'generated-document.pdf';\n      a.click();\n    }\n  };\n\n  if (loading) return React.createElement('div', null, 'Loading PDF module...');\n  if (error) return React.createElement('div', null, 'Error: ' + error.message);\n\n  return React.createElement('div', null,\n    React.createElement('h3', null, 'PDF Functions Available: ' + functions.length),\n    React.createElement('textarea', {\n      value: content,\n      onChange: (e) =\u003e setContent(e.target.value),\n      placeholder: 'PDF content',\n      rows: 5,\n      cols: 50\n    }),\n    React.createElement('br'),\n    React.createElement('button', { onClick: generatePDF }, 'Generate PDF'),\n    pdfResult \u0026\u0026 React.createElement('div', { style: { marginTop: '10px' } },\n      pdfResult.error\n        ? React.createElement('div', { style: { color: 'red' } }, 'Error: ' + pdfResult.error)\n        : React.createElement('div', { style: { color: 'green' } },\n            'âœ… PDF generated successfully!',\n            React.createElement('br'),\n            'ðŸ“„ Size: ' + pdfResult.size + ' bytes',\n            React.createElement('br'),\n            'ðŸ“‹ Pages: ' + pdfResult.pages\n          )\n    )\n  );\n}",
      "language": "jsx",
      "title": "React Hook Integration"
    }
  ],
  "fileInfo": {
    "binarySize": "4.4 MB",
    "compressedSize": "1.3 MB",
    "compressionRatio": "71%",
    "sourceLines": 563
  },
  "functions": [
    {
      "description": "Generate PDF from scratch with custom pages and metadata",
      "errorPattern": "Returns object with 'error' field on failure",
      "example": "const pages = JSON.stringify([{content: 'Hello World', margin: 10}]);\nconst metadata = JSON.stringify({title: 'My Document', author: 'John Doe'});\nconst result = pdf.call('createPDF', pages, metadata);\nif (result.error) {\n  console.error('PDF creation failed:', result.error);\n} else {\n  console.log('PDF created:', result.size, 'bytes, pages:', result.pages);\n}",
      "name": "createPDF",
      "parameters": [
        {
          "description": "JSON string of page configurations with content, dimensions, and margins",
          "name": "pages",
          "type": "string"
        },
        {
          "description": "Optional JSON string of PDF metadata (title, author, subject)",
          "name": "metadata",
          "type": "string"
        }
      ],
      "returnType": "object"
    },
    {
      "description": "Add a new page to existing PDF document",
      "errorPattern": "Returns object with 'error' field on failure",
      "example": "const pageContent = JSON.stringify({content: 'New page content', width: 210, height: 297});\nconst result = pdf.call('addPage', existingPdfData, pageContent);",
      "name": "addPage",
      "parameters": [
        {
          "description": "Base64-encoded PDF data",
          "name": "pdfData",
          "type": "string"
        },
        {
          "description": "JSON string of page configuration",
          "name": "pageContent",
          "type": "string"
        }
      ],
      "returnType": "object"
    },
    {
      "description": "Extract text content from PDF document",
      "errorPattern": "Returns object with 'error' field on failure",
      "example": "const result = pdf.call('extractText', pdfData, '1,3-5');\nif (result.error) {\n  console.error('Text extraction failed:', result.error);\n} else {\n  console.log('Extracted text:', result.text);\n}",
      "name": "extractText",
      "parameters": [
        {
          "description": "Base64-encoded PDF data",
          "name": "pdfData",
          "type": "string"
        },
        {
          "description": "Optional comma-separated page numbers (e.g., '1,3,5-7')",
          "name": "pageRange",
          "type": "string"
        }
      ],
      "returnType": "object"
    },
    {
      "description": "Extract images from PDF document",
      "errorPattern": "Returns object with 'error' field on failure",
      "example": "const result = pdf.call('extractImages', pdfData);\nif (result.error) {\n  console.error('Image extraction failed:', result.error);\n} else {\n  console.log('Extracted', result.count, 'images');\n  result.images.forEach(img =\u003e console.log('Image:', img.format, img.width + 'x' + img.height));\n}",
      "name": "extractImages",
      "parameters": [
        {
          "description": "Base64-encoded PDF data",
          "name": "pdfData",
          "type": "string"
        }
      ],
      "returnType": "object"
    },
    {
      "description": "Merge multiple PDF documents into one",
      "errorPattern": "Returns object with 'error' field on failure",
      "example": "const pdfs = JSON.stringify([pdfData1, pdfData2, pdfData3]);\nconst result = pdf.call('mergePDFs', pdfs);\nif (result.error) {\n  console.error('Merge failed:', result.error);\n} else {\n  console.log('Merged PDF:', result.pages, 'pages,', result.size, 'bytes');\n}",
      "name": "mergePDFs",
      "parameters": [
        {
          "description": "JSON string array of base64-encoded PDF data",
          "name": "pdfArray",
          "type": "string"
        }
      ],
      "returnType": "object"
    },
    {
      "description": "Split PDF document into separate parts",
      "errorPattern": "Returns object with 'error' field on failure",
      "example": "const ranges = JSON.stringify(['1-2', '3-4', '5']);\nconst result = pdf.call('splitPDF', pdfData, ranges);\nif (result.error) {\n  console.error('Split failed:', result.error);\n} else {\n  console.log('Split into', result.parts, 'PDFs');\n  result.splitPDFs.forEach(part =\u003e console.log('Part', part.partIndex, ':', part.pageRange));\n}",
      "name": "splitPDF",
      "parameters": [
        {
          "description": "Base64-encoded PDF data",
          "name": "pdfData",
          "type": "string"
        },
        {
          "description": "JSON string array of page ranges (e.g., ['1-3', '4-6', '7'])",
          "name": "ranges",
          "type": "string"
        }
      ],
      "returnType": "object"
    },
    {
      "description": "Add watermark text to PDF document",
      "errorPattern": "Returns object with 'error' field on failure",
      "example": "const watermark = JSON.stringify({text: 'CONFIDENTIAL', opacity: 0.3, rotation: 45});\nconst result = pdf.call('addWatermark', pdfData, watermark);\nif (result.error) {\n  console.error('Watermark failed:', result.error);\n} else {\n  console.log('Watermarked PDF:', result.size, 'bytes');\n}",
      "name": "addWatermark",
      "parameters": [
        {
          "description": "Base64-encoded PDF data",
          "name": "pdfData",
          "type": "string"
        },
        {
          "description": "JSON string of watermark configuration (text, opacity, rotation, etc.)",
          "name": "watermarkData",
          "type": "string"
        }
      ],
      "returnType": "object"
    },
    {
      "description": "Generate PDF report from data and template",
      "errorPattern": "Returns object with 'error' field on failure",
      "example": "const data = JSON.stringify({title: 'Sales Report', rows: [{name: 'Product A', sales: 1000}]});\nconst template = JSON.stringify({type: 'table'});\nconst result = pdf.call('generateReport', data, template);\nif (result.error) {\n  console.error('Report generation failed:', result.error);\n} else {\n  console.log('Generated report:', result.templateType, result.size, 'bytes');\n}",
      "name": "generateReport",
      "parameters": [
        {
          "description": "JSON string of report data",
          "name": "data",
          "type": "string"
        },
        {
          "description": "JSON string of template configuration",
          "name": "template",
          "type": "string"
        }
      ],
      "returnType": "object"
    },
    {
      "description": "Get PDF metadata and document information",
      "errorPattern": "Returns object with 'error' field on failure",
      "example": "const result = pdf.call('getPDFInfo', pdfData);\nif (result.error) {\n  console.error('Info extraction failed:', result.error);\n} else {\n  console.log('PDF info:', result.pages, 'pages,', result.size, 'bytes');\n  console.log('Title:', result.title, 'Author:', result.author);\n}",
      "name": "getPDFInfo",
      "parameters": [
        {
          "description": "Base64-encoded PDF data",
          "name": "pdfData",
          "type": "string"
        }
      ],
      "returnType": "object"
    },
    {
      "description": "Compress PDF file with configurable compression level",
      "errorPattern": "Returns object with 'error' field on failure",
      "example": "const result = pdf.call('compressPDF', pdfData, 'high');\nif (result.error) {\n  console.error('Compression failed:', result.error);\n} else {\n  console.log('Compressed from', result.originalSize, 'to', result.compressedSize, 'bytes');\n  console.log('Compression ratio:', result.compressionRatio + '%');\n}",
      "name": "compressPDF",
      "parameters": [
        {
          "description": "Base64-encoded PDF data",
          "name": "pdfData",
          "type": "string"
        },
        {
          "description": "Compression level: 'low', 'medium', 'high' (optional, default: 'medium')",
          "name": "compressionLevel",
          "type": "string"
        }
      ],
      "returnType": "object"
    },
    {
      "description": "Enable or disable console logging for operations",
      "errorPattern": "No errors expected",
      "example": "pdf.call('setSilentMode', true); // Disable logging\npdf.call('setSilentMode', false); // Enable logging",
      "name": "setSilentMode",
      "parameters": [
        {
          "description": "True to enable silent mode, false to show logs",
          "name": "silent",
          "type": "boolean"
        }
      ],
      "returnType": "boolean"
    },
    {
      "description": "Get list of all available PDF functions",
      "errorPattern": "No errors expected",
      "example": "const functions = pdf.call('getAvailableFunctions');\nconsole.log('Available functions:', functions);",
      "name": "getAvailableFunctions",
      "parameters": [],
      "returnType": "array"
    }
  ],
  "gowmConfig": {
    "autoDetect": true,
    "errorPattern": "object-based",
    "preferredFilename": "main.wasm",
    "readySignal": "__gowm_ready",
    "standardFunctions": [
      "getAvailableFunctions",
      "setSilentMode"
    ],
    "supportedBranches": [
      "master",
      "stable"
    ]
  },
  "gzipSize": 1327606,
  "license": "MIT",
  "name": "pdf-wasm",
  "performance": {
    "features": [
      "Compiled WebAssembly for optimal performance",
      "Native Go PDF processing",
      "Efficient memory usage for large documents",
      "Silent mode for production environments",
      "Optimized for GoWM integration",
      "Streaming PDF processing"
    ]
  },
  "quality": {
    "documentation": "complete",
    "maintainability": "high",
    "stability": "stable",
    "testing": "comprehensive"
  },
  "security": {
    "features": [
      "Memory-safe Go implementation",
      "Input validation and sanitization",
      "Secure PDF data handling",
      "Base64 encoding for web compatibility",
      "No external network dependencies",
      "Sandboxed WebAssembly execution"
    ]
  },
  "size": 4620519,
  "tags": [
    "pdf",
    "document",
    "generation",
    "manipulation",
    "extraction",
    "watermark",
    "merge",
    "split",
    "wasm",
    "go",
    "gowm"
  ],
  "types": [
    {
      "description": "Standard result type for PDF operations",
      "details": "Returns object with PDF data on success, or object with 'error' field on failure",
      "name": "PDFResult",
      "type": "object"
    },
    {
      "description": "PDF creation operation result",
      "name": "PDFCreationResult",
      "properties": {
        "error": "string (optional, present on failure)",
        "format": "string ('application/pdf')",
        "metadata": "object (PDF metadata)",
        "pages": "number (total number of pages)",
        "pdfData": "string (base64-encoded PDF data)",
        "size": "number (PDF size in bytes)"
      }
    },
    {
      "description": "Text/image extraction result",
      "name": "PDFExtractionResult",
      "properties": {
        "count": "number (number of extracted items)",
        "error": "string (optional, present on failure)",
        "images": "array (extracted image objects)",
        "pages": "number (number of processed pages)",
        "text": "string (extracted text content)"
      }
    },
    {
      "description": "PDF compression operation result",
      "name": "PDFCompressionResult",
      "properties": {
        "compressedSize": "number (compressed size in bytes)",
        "compressionLevel": "string (compression level used)",
        "compressionRatio": "number (compression ratio percentage)",
        "error": "string (optional, present on failure)",
        "originalSize": "number (original size in bytes)",
        "pdfData": "string (base64-encoded compressed PDF)"
      }
    }
  ],
  "usageStats": {
    "averageCallTime": "5-50ms",
    "complexity": "intermediate",
    "concurrency": "thread-safe",
    "memoryUsage": "moderate"
  },
  "version": "0.1.0",
  "wasmConfig": {
    "filename": "main.wasm",
    "globalFunctions": true,
    "goWasmExecRequired": true,
    "memoryInitialPages": 512,
    "memoryMaximumPages": 2048,
    "readySignal": "__gowm_ready"
  }
}